const PublicParameters = artifacts.require("PublicParameters.sol");
const util = require("util");
const ethUtil = require('ethereumjs-util')
const BN = ethUtil.BN;
const {GeneratorParams} = require("../prover/rangeProof/generatorParams")
const {ECCurve} = require("../prover/curve/curve")
const t = require('truffle-test-utils')
t.init()
// const expectThrow = require("../helpers/expectThrow");

const M = 64;
const N = 6;
contract('PublicParameters', async (accounts) => {

    var publicParams;

    const operator = accounts[0]

    beforeEach(async () => {
        publicParams = await PublicParameters.new({from: operator})
    })

    it('do setup', async () => {
        const group = new ECCurve("bn256")
        const parameters = GeneratorParams.generateParams(256, group);

        const g = parameters.getBase().g;
        const h = parameters.getBase().h;
        const g_x = await publicParams.baseG(0);
        const g_y = await publicParams.baseG(1);
        const h_x = await publicParams.baseH(0);
        const h_y = await publicParams.baseH(1);
        assert(g_x.cmp(g.getX()) === 0, "Failed at G_X")
        assert(g_y.cmp(g.getY()) === 0, "Failed at G_Y")
        assert(h_x.cmp(h.getX()) === 0, "Failed at H_X")
        assert(h_y.cmp(h.getY()) === 0, "Failed at H_Y")

        for (let i = 0; i < M/8; i++) {
            try{
                const res = await publicParams.createGVector()
            } catch(err) {
                console.log("G")
                console.log("i = " + i);
                console.log(err)
            }
        }
        for (let i = 0; i < M/8; i++) {
            try{
                const res = await publicParams.createHVector()
            } catch(err) {
                console.log("H")
                console.log("i = " + i);
                console.log(err)
            }
        }

        let vectorsRef = parameters.getVectorBase().getGs().getVector();
        for (let i = 0; i < M; i++) {
            try{
                const x = await publicParams.gVector(2*i)
                const y = await publicParams.gVector(2*i + 1)
                const v = vectorsRef[i];
                if (x.cmp(v.getX()) !== 0 || y.cmp(v.getY()) !== 0) {
                    console.log("G vector")
                    console.log("Ref x = " + v.getX().toString(16));
                    console.log("Ref y = " + v.getY().toString(16));
                    console.log("Created x = " + x.toString(16));
                    console.log("Created y = " + y.toString(16));
                    throw Error("Reference is different from created one");
                }
            } catch(err) {
                console.log("G vector")
                console.log("i = " + i);
                console.log(err)
            }
        }
        vectorsRef = parameters.getVectorBase().getHs().getVector();
        for (let i = 0; i < M; i++) {
            try{
                const x = await publicParams.hVector(2*i)
                const y = await publicParams.hVector(2*i + 1)
                const v = vectorsRef[i];
                if (x.cmp(v.getX()) !== 0 || y.cmp(v.getY()) !== 0) {
                    console.log("H vector")
                    console.log("Ref x = " + v.getX().toString(16));
                    console.log("Ref y = " + v.getY().toString(16));
                    console.log("Created x = " + x.toString(16));
                    console.log("Created y = " + y.toString(16));
                    throw Error("Reference is different from created one");
                }
            } catch(err) {
                console.log("H vector")
                console.log("i = " + i);
                console.log(err)
            }
        }
    })
})
